# Turbo File Copier — детальний опис

Turbo File Copier — це невелика десктопна утиліта на Python для швидкого, прозорого та контрольованого копіювання файлів. Програма зручна для роботи з великими файлами (відео, образи дисків, резервні копії), де важливо відслідковувати прогрес і мати можливість призупинити або скасувати операцію.

Цей README містить повний опис архітектури, принципів роботи, інтерфейсу та інструкції з запуску і налагодження.

## Головні можливості

- Паралельне (мультипоточне) копіювання файлів: великий файл ділиться на кілька частин і кожна частина копіюється своїм потоком.
- Відображення загального прогресу і окремого прогресу для кожного потоку.
- Pause / Resume — тимчасова зупинка і відновлення копіювання.
- Cancel — коректне скасування поточної операції.
- Нативний, простий GUI на Tkinter з сучасною палітрою (сірі кольори + світло-фіолетові акценти) і заокругленими кнопками.

## Файлова структура проекту

- `copier.py` — ядро логіки. Містить клас `FileCopier`.
  - Основні методи: `copy_file(source, destination, progress_callback)`, `pause()`, `resume()`, `cancel()`, `get_speed()`.
- `gui.py` — графічний інтерфейс (Tkinter). Містить `TurboFileCopierGUI` та допоміжний `RoundedButton`.
- `main.py` — точка запуску програми; створює вікно Tk і запускає GUI.
- `README.md` — (цей файл) інструкції та опис.

## Детальний опис роботи (технічно)

1) Визначення режиму копіювання:
	- При виклику `copy_file(source, destination)` клас `FileCopier` перевіряє розмір `source`.
	- Якщо розмір <= `chunk_size` (параметр конструктора), виконується послідовне копіювання (один потік).
	- Якщо розмір > `chunk_size`, файл ділиться на `num_threads` частин (`calculate_chunks`) і для кожної частини запускається окремий `thread`, що виконує `_copy_chunk`.

2) Як копіює кожен потік (`_copy_chunk`):
	- Відкриває `source` у режимі `rb` і `destination` у режимі `r+b` (читає та записує у певну позицію).
	- `seek(start)` у обох файлах, і читає блоками (наприклад, 64 KB) зі `source`, записує у `destination` у відповідну позицію.
	- Після кожного запису під `_lock` оновлює `self.copied_size` та `self.thread_progress[thread_id]` — це дозволяє коректно сумувати прогрес з різних потоків.
	- Перед кожною ітерацією перевіряє прапори `is_paused` (точка паузи: цикл очікує з коротким sleep) і `is_cancelled` (прямий вихід і завершення потоку).

3) Моніторинг і зворотний зв'язок:
	- Головний потік `copy_file` запускає всі робочі потоки і періодично (наприклад, кожні 0.2 с) збирає `copied_size` та `thread_progress`, обчислює відсоток і швидкість (MB/s) і викликає `progress_callback(total_pct, speed, thread_progress_dict)`.
	- GUI передає в `copy_file` власний `progress_callback`, який через `root.after(0, ui_update)` оновлює віджети без порушення головного Tk-потоку.

4) Завершення:
	- Після завершення всіх потоків `copy_file` перевіряє `self.error` і `is_cancelled` і повертає словник результату з полями `{ 'success': bool, 'time': float, 'speed': float, 'size': int, 'error': Optional[str] }`.

## Інтерфейс користувача (GUI)

- Поля: `Source` (вхідний файл), `Destination` (файл-ціль).
- Налаштування: слайдер `Threads` — кількість потоків (наприклад, від 1 до 16).
- Прогрес:
  - Загальний progressbar і рядок із швидкістю (MB/s).
  - Список рядків / progressbar'ів для кожного потоку — показує, яка частина ділянки завершена.
- Кнопки: `START COPY`, `PAUSE / RESUME`, `CANCEL` — реалізовані як заокруглені Canvas-кнопки.

Поводження кнопок:
- `START COPY` — блокується під час роботи; викликає `copy_file` у фоновому потоці.
- `PAUSE` — виставляє `is_paused=True` у `FileCopier`; потоки зупиняються у своїх циклах.
- `RESUME` — знімає паузу (`is_paused=False`).
- `CANCEL` — виставляє `is_cancelled=True`; після цього всі потоки за можливості завершують свою роботу і процес повертає статус 'cancelled'.

## Запуск програми

1) Відкрий PowerShell в папці проекту або перейдіть в екземпляр файлового менеджера, де розміщено проект.
2) Запустіть:
```powershell
py -3 "c:\Users\yarik\OneDrive\Рабочий стол\Курсова робота\main.py"
```

Альтернатива: створіть простий `run_turbo_copy.bat` з рядком вище — тоді можна запускати через подвійний клік.

## Валідація та налагодження

- Перевірка наявності `tkinter` (іноді у мінімальних інсталяціях Python його немає):
```powershell
py -3 -c "import tkinter; print('tkinter OK')"
```
- Якщо програма аварійно завершується — після останнього запуску може з'явитися файл `error.log` у тій же папці з повним traceback; надішліть його мені для діагностики.

## Обмеження, ризики і технічні зауваження

- Продуктивність паралельного копіювання сильно залежить від носія: SSD частіше показує прискорення, HDD — іноді отримує деградацію через конкурентні головки.
- Мережеві шляхи (SMB, NFS) можуть мати інші характеристики й обмеження — будьте уважні при копіюванні через мережу.
- У разі аварійного завершення програми, файл `destination` може залишитися частково записаним. Якщо потрібна атомарність, реалізуйте копію в тимчасовий файл і перейменування після успіху.
- Немає вбудованої перевірки цілісності (checksum) — її можна додати як опцію після копіювання.

## Тестування (локальний тест)

Невеликий headless-тест уже включався під час розробки (файл `test_copy.py` або аналог), який створює випадкові дані і перевіряє, що `FileCopier.copy_file` повертає `success=True` і що розмір відповідає очікуваному. Щоб прогнати свій локальний тест, можна створити скрипт, який генерує тестовий файл і запускає копіювання у тимчасовий файл.

Приклад (псевдо-скрипт для тесту):
```python
from copier import FileCopier
f = FileCopier(num_threads=4, chunk_size=1024*1024)
res = f.copy_file('big_test_src.bin', 'big_test_dst.bin', progress_callback=lambda p,s,tp: print(f"{p:.1f}% {s:.2f}MB/s"))
print(res)
```

## Як зробити виконуваний `.exe` (опціонально)

1. Встановіть PyInstaller:
```powershell
py -3 -m pip install pyinstaller
```
2. Зберіть одноручний `exe` без вікна консолі:
```powershell
py -3 -m PyInstaller --noconfirm --onefile --windowed main.py
```
Після цього виконуваний файл з'явиться в папці `dist\`.

## Ідеї для подальшого розвитку

- Додавання валідації контрольних сум (MD5/SHA) після копіювання для перевірки цілісності.
- Логування в файл з деталями операцій (шляхи, час, швидкість, помилки).
- Краще візуальне оформлення списку потоків (картки, піктограми, прогрес у формі pill-бара).
- Збереження останніх шляxів/налаштувань (config) між запусками.
- Рефакторинг UI на PySide/PyQt для більш професійного та анімаційного інтерфейсу.

---

Якщо хочеш, я перероблю README ще більш компактно (коротка інструкція для друзів) або додам розділ з прикладами команд для тестування. Дай знати, що зробити наступним.
